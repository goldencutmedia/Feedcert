"use strict";
// Copyright IBM Corp. and LoopBack contributors 2019. All Rights Reserved.
// Node module: @loopback/logging
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpAccessLogInterceptor = exports.InvocationLoggingInterceptor = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@loopback/core");
const rest_1 = require("@loopback/rest");
const morgan_1 = tslib_1.__importDefault(require("morgan"));
const util_1 = require("util");
const winston_1 = require("winston");
const keys_1 = require("../keys");
/**
 * A local interceptor that provides logging for method invocations.
 */
let InvocationLoggingInterceptor = class InvocationLoggingInterceptor {
    constructor(logger) {
        this.logger = logger;
    }
    value() {
        return this.intercept.bind(this);
    }
    async intercept(invocationCtx, next) {
        try {
            this.logger.log('verbose', (0, util_1.format)('invoking %s with:', invocationCtx.targetName, invocationCtx.args));
            const result = await next();
            this.logger.log('verbose', (0, util_1.format)('returned from %s:', invocationCtx.targetName, result));
            return result;
        }
        catch (err) {
            this.logger.log('error', (0, util_1.format)('error from %s', invocationCtx.targetName, err));
            throw err;
        }
    }
};
exports.InvocationLoggingInterceptor = InvocationLoggingInterceptor;
exports.InvocationLoggingInterceptor = InvocationLoggingInterceptor = tslib_1.__decorate([
    (0, core_1.injectable)({
        tags: { [core_1.ContextTags.KEY]: keys_1.LoggingBindings.WINSTON_INVOCATION_LOGGER },
        scope: core_1.BindingScope.SINGLETON,
    }),
    tslib_1.__param(0, (0, core_1.inject)(keys_1.LoggingBindings.WINSTON_LOGGER)),
    tslib_1.__metadata("design:paramtypes", [winston_1.Logger])
], InvocationLoggingInterceptor);
/**
 * A global interceptor that provides logging for http requests/responses.
 */
let HttpAccessLogInterceptor = class HttpAccessLogInterceptor {
    constructor(logger, morganOptions = { format: 'combined' }) {
        this.logger = logger;
        this.morganOptions = morganOptions;
    }
    value() {
        return this.intercept.bind(this);
    }
    async intercept(invocationCtx, next) {
        var _a;
        const reqCtx = await invocationCtx.get(rest_1.RestBindings.Http.CONTEXT);
        const options = {
            ...this.morganOptions,
            stream: {
                write: (message) => {
                    this.logger.info(message);
                },
            },
        };
        if (typeof options.format === 'function') {
            (0, morgan_1.default)(options.format, options)(reqCtx.request, reqCtx.response, () => { });
        }
        else {
            (0, morgan_1.default)((_a = options.format) !== null && _a !== void 0 ? _a : 'combined', options)(reqCtx.request, reqCtx.response, () => { });
        }
        return next();
    }
};
exports.HttpAccessLogInterceptor = HttpAccessLogInterceptor;
exports.HttpAccessLogInterceptor = HttpAccessLogInterceptor = tslib_1.__decorate([
    (0, core_1.injectable)((0, core_1.asGlobalInterceptor)('logging'), {
        tags: {
            [core_1.ContextTags.KEY]: keys_1.LoggingBindings.WINSTON_HTTP_ACCESS_LOGGER,
            // Only apply to invocations from REST routes
            [core_1.ContextTags.GLOBAL_INTERCEPTOR_SOURCE]: 'route',
        },
        scope: core_1.BindingScope.SINGLETON,
    }),
    tslib_1.__param(0, (0, core_1.inject)(keys_1.LoggingBindings.WINSTON_LOGGER)),
    tslib_1.__param(1, (0, core_1.config)()),
    tslib_1.__metadata("design:paramtypes", [winston_1.Logger, Object])
], HttpAccessLogInterceptor);
//# sourceMappingURL=logging.interceptor.js.map